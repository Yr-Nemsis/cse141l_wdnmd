100110111   //r6 = 111  int index = 30
100111001
111110111   //r6 = 1110
000110111   //r6 = 1111
111110111   //r6 = 11110 (30)
100111000
000111110   //r7 = 11110
100000001
111111000   //r7 = 111100(60)
100000001
000000111   //r0 = 111101 (61)
110110000   //data_mem[61] = index
100001001
000000001   //r0 = 111110 (62)
110111000   //data_mem[62] = 60
101000110   //r0 is lsw
100001001
000110001   //r6 = index+1
101001110   //r1 is msw
100010000   //r2 is bitPos，loop:
100011101   //r3 is t1，calculate p1
100100100   //r4 = 4
111011100   //r3 = 1010000
100100101
000011100   //r3 = 1010101
100100001
111011100   //r3 = 10101010
100100000
000100011   //r4 = 10101010
001011000   //r3 = lsw && 10101010
010011011   //r3 = ^r3
001100001   //r4 = msw && 10101010
010100100   //r4 = ^r4
010011100   //t1 = t1^t2
000010011   //bitPos += t1;
100011110   //calculate p2
100100011   //r4 = 3
111011100   //r3 = 110000
100100011
000011100   //r3 = 110011
100100010   //r4 = 2
111011100   //r3 = 11001100
100100000
000100011   //r4 = 11001100
001011000   //r3 = lsw ^ 1100 1100
010011011
001100001   //r4 = msw ^ 1100 1100
010100100
010011100
100100001
111011100   //r3 = p2 0
000010011
100011111   //calculate p4
100100011
111011100   //r3 = 111000
100100100
000011100   //r3 = 111100
100100010
111011100   //r3 = 11110000
100100000
000100011   //r4 = 11110000
001011000   //r3 = 11110000 ^ lsw
010011011
001100001   //r4 = 11110000 ^ msw
010100100
010011100
100100010
111011100
000010011   //r2 = p4 p2 p1
100011000   //calculate p0
000011000
010011011   //r3 = ^lsw
100100000
000100001
010100100   //r4 = ^msw
010011100   //r3 is f1 now
100100000   //calculate p8
000100001   //r4 = msw
010100100   //r4 = ^msw
100101011
111100101   //r4 = p8 0 0 0
000010100   //r2 = p8 p4 p2 p1
100100000   //r4 = f0 = 0
100110000
000110010   //r2r6 = bitpos = p8 p4 p2 p1
100111000
011010010   //beq skip1 = beq 18
100100001   //r3 is f1 r4 is f0
100101111   //data_mem[63(0011 1111)] = f0 skip1:
100110011   //r6 = 3
111101110   //r5 = 111000
100110111
000101110   //r5 = 111111(63)
110100101
100110001
000101110   //r5 = 64 //data_mem[64(0100 0000)] = f1
110011101
100110000
000110011   //r6 = f1
011010011   //beq skip2 = beq 19
100101001   //r5 is pos
100110000
000110010   //r6 = bitpos
100100111
100011011   //r3 = 3
111100011   //r4 = 111000
100011110
000100011   //r4 = 111110
100011010
111100011   //r4 = 11111000
001110100   //r6 = bitpos && 11111000
011010100   //beq small = beq 20 if bitpos <= 7
000010100   //r2(bitpos) = r2 - 8 = bitpos - 8
111101010   //r5(pos) = r5 << bitpos
010001101   //msw = msw ^ pos
100110000
100111000
011010101   //beq skip2 = beq 21
111101010   //pos = pos << bitPos small:
010000101   //lsw = lsw ^ pos
100100111   //skip2:
100101011
111100101   //r4 = 111000
100101101
000100101   //r4 = 0011 1101 (61)
101110100   //r6 = index
100101001
000100101   //r4 = 0011 1110 (62)
101111100   //r7 = 60
000100101   //r4 = 63
101010100   //r2 = f0
000100101   //r4 = 64
101011100   //r3 = f1
111011101   //r3 = f1 0
000011010   //r3 = f1 f0
100101110   //r5 = 6
111011101   //r3 = f1 f0 00 0000
000001011   //r1 = F1 F0 0 0 0 D11 D10 D9
100100111
100101101
111100101
100101010
000100101
000100110
110000100   //data_mem[index] = lsw
100101001
000110101   //index + 1
000100101
110001100   //data_mem[index+1] = msw
000110101   //index = index + 1 = new index
011010110   //beq end = beq 22 if index = 60 end loop
100100111
100101011
111100101   //r4 = 111000
100101101
000100101   //r4 = 111101 (61)
110110100   //data_mem[61] = index
101000110   //r0 is lsw
100001001
000110001   //r6 = index + 1
101001110   //r1 is msw
100110000
100111000
011010111   //beq loop = beq 23 158: end:
